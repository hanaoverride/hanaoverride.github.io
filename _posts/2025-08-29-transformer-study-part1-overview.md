---
layout: post
title: "Transformer 스터디 (1) 전체 로드맵 & 왜 다시 공부했나"
date: 2025-08-29 09:05:12 +0900
categories: [llm-engineering]
tags: [Transformer, 로드맵, 스터디소개, 배경, 딥러닝]
redirect_from:
  - /llm-engineering/2025/08/29/transformer-study-part1/
---
# Transformer가 뭐길래? - 혁신의 시작점

> *"Attention Is All You Need" 논문 한 줄로 AI의 역사가 바뀌었다고요? 정말일까요?*

## 시작하기 전에

저는 AI 부트캠프인 이어드림스쿨의 데이터 사이언스 트랙을 듣고 있었습니다.
그 중에서는 특히 언어모델에 관심이 있는 학생들이 많았고, 공부를 하고 싶은 학생을 모았어요.

학생을 모아놓고 무엇을 하고 싶은지 물었습니다. 보안? 응용? 이론적 토대?

많은 학생들이 이론적 토대에 대한 심층적 이해를 더 원했고, 저는 우선 Transformer 아키텍쳐를 모르고는 절대로 현대 언어모델을 이해할 수 없다는 생각이 들었기 때문에 스터디 주제를 우선 Transformer로 진행하고, 추후 다른 아키텍쳐도 연구해보기로 했습니다.

그래서 팀 스터디를 시작했습니다. 3개월간 "Attention Is All You Need" 논문을 샅샅이 파헤치고, 직접 코드를 짜보고, 실험해봤죠. 오늘부터 그 여정을 여러분과 함께 나누려고 해요.

> 스터디에 나온 담화는 이해를 돕기 위해 실제 대화를 재구성하였고, 스터디원의 실제 이름과도 다릅니다! 또한 결과값이 주어지지 않은 코드 스니펫은 독자의 이해를 돕기 위한 의사 코드로, 실행해도 별 결과가 없습니다.

## RNN의 시대, 그리고 한계

### 순차처리의 굴레

2017년 이전, 자연어 처리의 주인공은 RNN(Recurrent Neural Network)이었어요. 문장을 앞에서부터 차례대로 읽어가며 정보를 기억하는 방식이죠.

```python
# RNN의 처리 방식 (의사코드)
sentence = "나는 학교에 간다"
hidden_state = [0, 0, 0, ...]

for word in sentence:
    hidden_state = process(word, hidden_state)
    # "나는" -> "학교에" -> "간다" 순서대로 처리
```

**스터디 토론 중 나온 질문:**

> **민수**: "RNN이 뭐가 문제인 거야? 사람도 글을 순서대로 읽잖아."
> 
> **지영**: "그런데 생각해봐. '나는 어제 친구와 함께 영화관에서 정말 재미있는 액션 영화를 봤다'는 문장에서 '봤다'를 처리할 때, '나는'이라는 정보가 남아있을까?"
> 
> **민수**: "아... 문장이 길어질수록 앞의 정보가 희미해지겠네."

바로 그거였어요. **기울기 소실(Vanishing Gradient)** 문제죠.

### 병목현상의 현실

더 큰 문제는 **병렬처리 불가능**이었어요.

```
RNN 처리 순서:
Step 1: "나는" 처리 → hidden_state_1
Step 2: "학교에" + hidden_state_1 → hidden_state_2  
Step 3: "간다" + hidden_state_2 → hidden_state_3

각 단계는 이전 단계가 끝나야 시작 가능!
```

GPU의 병렬처리 능력을 제대로 활용할 수 없었죠. 긴 문장일수록, 더 많은 데이터일수록 학습 시간이 기하급수적으로 늘어났어요.

## Attention의 등장 - 게임 체인저

### "모든 단어가 모든 단어를 본다"

Transformer의 핵심 아이디어는 단순하면서도 혁명적이었어요:

**"순서대로 처리하지 말고, 모든 단어가 동시에 모든 단어를 보게 하자!"**

```python
# Transformer의 처리 방식 (개념적)
sentence = ["나는", "학교에", "간다"]

# 모든 단어 쌍의 관련도를 동시에 계산
attention_matrix = [
    ["나는"→"나는", "나는"→"학교에", "나는"→"간다"],
    ["학교에"→"나는", "학교에"→"학교에", "학교에"→"간다"], 
    ["간다"→"나는", "간다"→"학교에", "간다"→"간다"]
]
```

**스터디에서 나온 "아하!" 순간:**

> **현우**: "잠깐, 그럼 '간다'를 처리할 때 '나는'의 정보를 바로 참조할 수 있다는 거야?"
> 
> **지영**: "맞아! 거리가 얼마나 멀든 상관없이!"
> 
> **민수**: "그리고 모든 계산이 동시에 일어나니까 병렬처리도 가능하고!"

정확히 그거였어요. **장거리 의존성(Long-range Dependency)**과 **병렬처리** 두 마리 토끼를 한 번에 잡은 거죠.

## Self-Attention의 마법

### Query, Key, Value - 관계형 데이터베이스의 은유

Attention 메커니즘을 처음 접하면 Query, Key, Value라는 용어가 낯설게 느껴져요. 하지만 우리가 익숙한 관계형 데이터베이스에서 데이터를 조회하는 과정을 떠올리면 훨씬 직관적이에요. 당시 교육과정에서 SQL을 다루고 있었기 때문에 스터디원들이 공부 경험을 살릴 수 있도록 SQL 비유를 들었어요.

```
관계형 데이터베이스 테이블을 생각해봅시다 (예: orders 테이블):
- Query: SELECT * FROM orders WHERE user_id = 42; 처럼 '무엇을 찾고 싶은지'를 표현한 질의
- Key: 인덱스(Primary Key나 user_id 같은 인덱싱된 컬럼의 값들) — 어떤 로우가 조건과 관련 있는지 빠르게 판별하기 위한 구조
- Value: 조건에 매칭된 실제 로우(행) 데이터 (선택/집계하여 가져올 내용)

Self-Attention도 유사합니다:
- Query: 현재 단어(토큰)가 "내가 지금 어떤 의미적/문맥적 정보를 참고하고 싶은가"를 담은 벡터
- Key: 각 단어가 가진 고유한 의미/특징을 인덱싱해둔 벡터 (매칭 대상)
- Value: 실제로 가중합되어 전달될 표현 벡터 (내용 자체)
```

### 실제 계산 과정

```python
# 간단한 예시
sentence = ["나는", "학교에", "간다"]

# 1. 각 단어를 Query, Key, Value 벡터로 변환
Q = transform_to_query(sentence)    # 찾고자 하는 것
K = transform_to_key(sentence)      # 검색될 대상  
V = transform_to_value(sentence)    # 실제 정보

# 2. 유사도 계산 (내적)
similarity = Q @ K.T  # 모든 단어 쌍의 관련도

# 3. 확률로 변환 (소프트맥스)
attention_weights = softmax(similarity)

# 4. 정보 합성
output = attention_weights @ V
```

**스터디 토론에서:**

> **지영**: "그런데 왜 하필 내적(dot product)으로 유사도를 계산하지?"
> 
> **현우**: "벡터의 내적이 방향 유사도를 나타내잖아. 같은 방향이면 큰 값, 수직이면 0이 되고."
> 
> **민수**: "아! 그럼 의미가 비슷한 단어들끼리는 높은 점수가 나오겠네!"

맞습니다. 수학이 언어의 의미를 포착하는 순간이죠.

## 왜 "All You Need"였을까?

### 기존 방식의 한계 극복

2017년 당시 최고 성능 모델들은 복잡한 구조를 가지고 있었어요:
- RNN + Attention
- CNN + RNN + Attention  
- 복잡한 인코더-디코더 구조

하지만 Transformer는 **오직 Attention만**으로 모든 문제를 해결했어요.

```
기존: RNN(순차처리) + Attention(관계파악)
Transformer: Self-Attention으로 모든 것을!
```

### 성능 혁신의 수치

논문에서 제시한 결과는 충격적이었어요:

- **번역 성능**: 기존 최고 성능 대비 2+ BLEU 점수 향상
- **학습 시간**: 병렬처리로 수십 배 단축
- **모델 크기**: 파라미터는 적으면서 성능은 더 좋음

**스터디 마지막 날 나온 깨달음:**

> **현우**: "결국 Transformer의 핵심은 '관계'를 보는 방식을 바꾼 거네."
> 
> **지영**: "맞아. 순서대로가 아니라 전체적으로!"
> 
> **민수**: "그래서 ChatGPT도 문맥을 이렇게 잘 이해하는구나..."

## 시리즈 로드맵 - 앞으로의 여행

이제 본격적인 여정이 시작됩니다. 앞으로 7편에 걸쳐 Transformer의 모든 구성요소를 파헤쳐볼 거예요:

### 다음 편 예고: "위치를 기억하는 마법"
> *Transformer는 단어 순서를 어떻게 알까요? RNN처럼 순차처리를 하지 않는데도 "나는 학교에 간다"와 "학교에 나는 간다"를 구분할 수 있는 비밀은?*

**스터디에서 가장 신기해했던 부분 중 하나:**
"병렬처리하면서 순서도 기억한다고? 어떻게?"

### 전체 시리즈 구성
1. ✅ **Transformer의 등장 배경** (이번 편)
2. **Positional Encoding** - 순서 없이 순서 기억하기
3. **Feed Forward Network** - 정보 변환의 핵심
4. **Residual Connection & Layer Normalization** - 안정성의 기둥
5. **Self-Attention 수학** - Query, Key, Value의 진실
6. **Multi-Head Attention** - 여러 시선으로 보기
7. **임베딩과 토크나이징** - 단어를 숫자로
8. **전체 구현** - 모든 퍼즐 맞추기

## 마무리하며

Transformer를 이해한다는 건 단순히 새로운 기술을 배우는 게 아니에요. **AI가 언어를 처리하는 방식의 패러다임 전환**을 이해하는 거죠.

3개월간의 스터디를 통해 깨달은 건, Transformer의 각 구성요소가 모두 **명확한 이유**가 있다는 거였어요. 수학적 우아함과 실용적 효율성이 완벽하게 결합된 아키텍처죠.

다음 편에서는 "어떻게 순서 정보를 병렬처리와 함께 처리할 수 있을까?"라는 질문으로 Positional Encoding의 세계로 들어가겠습니다.

**여러분도 함께 여행해보실래요?**

---

*P.S. 실제로 코드를 따라해보시면서 읽으시길 추천해요. 이론만으로는 절대 느낄 수 없는 "아하!" 순간들이 있거든요.*

**다음 편에서 만나요! 👋**